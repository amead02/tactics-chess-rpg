<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tactics Chess RPG</title>
  <style>
    /* Basic page styling */
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      background: #f0f0f0;
    }
    h1 {
      margin-top: 0.5rem;
    }
    #board {
      /* 8×8 chess board */
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 2px solid #333;
      margin-top: 1rem;
    }
    .square {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      position: relative;
      cursor: pointer;
    }
    .square.dark {
      background: #769656;
    }
    .square.light {
      background: #eeeed2;
    }
    .square .hp {
      position: absolute;
      bottom: 2px;
      right: 2px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 4px;
      padding: 1px 3px;
      font-size: 10px;
      border: 1px solid #999;
    }
    .selected {
      outline: 3px solid #ff5555;
    }
    /* Modal for prompts and help */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.5);
    }
    .modal .content {
      background: #ffffff;
      padding: 20px;
      border-radius: 8px;
      max-width: 500px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    #log {
      margin-top: 1rem;
      width: 480px;
      height: 150px;
      overflow-y: auto;
      border: 1px solid #ccc;
      background: #ffffff;
      padding: 4px;
      font-size: 12px;
    }
    #controls {
      margin-top: 0.5rem;
    }
    #controls button {
      margin-right: 0.5rem;
    }
  </style>
</head>
<body>
  <h1>Tactics Chess RPG</h1>
  <div id="controls">
    <button id="howto">How to Play</button>
    <button id="reset">Reset</button>
    <label><input type="checkbox" id="accel" /> Accelerated Damage</label>
  </div>
  <div id="board"></div>
  <div id="log"></div>
  <!-- Generic modal for attack/defend prompts and rules -->
  <div id="modal" class="modal">
    <div class="content" id="modalContent"></div>
  </div>
  <script>
    // Piece statistics for HP and base damage
    const PIECE_STATS = {
      P: { hp: 2, dmg: 1 },
      N: { hp: 4, dmg: 2 },
      B: { hp: 4, dmg: 2 },
      R: { hp: 6, dmg: 3 },
      Q: { hp: 8, dmg: 4 },
      K: { hp: Infinity, dmg: 0 }, // King cannot be damaged
    };
    // Unicode symbols for pieces
    const UNICODE = {
      wP: '♙', wN: '♘', wB: '♗', wR: '♖', wQ: '♕', wK: '♔',
      bP: '♟', bN: '♞', bB: '♝', bR: '♜', bQ: '♛', bK: '♚',
    };
    // Game state variables
    let boardState;
    let turn;
    let selected;
    let defendTokens;
    const logDiv = document.getElementById('log');
    const boardDiv = document.getElementById('board');
    // Initialise or reset the game
    function init() {
      // Create empty 8×8 board
      boardState = Array.from({ length: 8 }, () => Array(8).fill(null));
      // Populate white pieces (top two rows)
      const order = ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'];
      for (let c = 0; c < 8; c++) {
        boardState[0][c] = { color: 'w', type: order[c], hp: PIECE_STATS[order[c]].hp };
        boardState[1][c] = { color: 'w', type: 'P', hp: PIECE_STATS.P.hp };
      }
      // Populate black pieces (bottom two rows)
      for (let c = 0; c < 8; c++) {
        boardState[7][c] = { color: 'b', type: order[c], hp: PIECE_STATS[order[c]].hp };
        boardState[6][c] = { color: 'b', type: 'P', hp: PIECE_STATS.P.hp };
      }
      // Defend tokens: each side starts with 3
      defendTokens = { w: 3, b: 3 };
      // White starts
      turn = 'w';
      selected = null;
      // Clear log
      logDiv.innerHTML = 'New game: White to move.<br>';
      render();
    }
    // Render the board and pieces
    function render() {
      boardDiv.innerHTML = '';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const sq = document.createElement('div');
          sq.classList.add('square');
          // Colouring the squares for checker pattern
          if ((r + c) % 2 === 0) sq.classList.add('light'); else sq.classList.add('dark');
          sq.dataset.row = r;
          sq.dataset.col = c;
          const piece = boardState[r][c];
          if (piece) {
            sq.textContent = UNICODE[piece.color + piece.type];
            // Show HP for non-king pieces
            if (piece.type !== 'K') {
              const hpBadge = document.createElement('span');
              hpBadge.className = 'hp';
              hpBadge.textContent = piece.hp;
              sq.appendChild(hpBadge);
            }
          }
          // Highlight if currently selected
          if (selected && selected.row === r && selected.col === c) {
            sq.classList.add('selected');
          }
          sq.addEventListener('click', onSquareClick);
          boardDiv.appendChild(sq);
        }
      }
    }
    // Handle click on a board square
    function onSquareClick(e) {
      const r = parseInt(e.currentTarget.dataset.row, 10);
      const c = parseInt(e.currentTarget.dataset.col, 10);
      const piece = boardState[r][c];
      // If a piece is selected, attempt move or deselect
      if (selected) {
        const from = selected;
        const to = { row: r, col: c };
        // Deselect if clicking the same square
        if (from.row === r && from.col === c) {
          selected = null;
          render();
          return;
        }
        // Switch selection if clicking another friendly piece
        if (piece && piece.color === turn) {
          selected = { row: r, col: c };
          render();
          return;
        }
        // Check if move is legal
        const moves = getLegalMoves(turn);
        const moveObj = moves.find(m => m.from.row === from.row && m.from.col === from.col && m.to.row === to.row && m.to.col === to.col);
        if (!moveObj) {
          // Illegal move: deselect
          selected = null;
          render();
          return;
        }
        // If target square has a piece, resolve combat; otherwise, simple move
        if (piece) {
          promptAttack(moveObj, from, to);
        } else {
          performMove(from, to);
          endTurn();
        }
      } else {
        // No piece selected: select if clicking own piece
        if (piece && piece.color === turn) {
          selected = { row: r, col: c };
          render();
        }
      }
    }
    // Move a piece from one square to another (simple non-capture move)
    function performMove(from, to) {
      const moving = boardState[from.row][from.col];
      boardState[to.row][to.col] = moving;
      boardState[from.row][from.col] = null;
      selected = null;
      render();
    }
    // Show a modal dialog with given HTML content
    function showModal(html) {
      const modal = document.getElementById('modal');
      const content = document.getElementById('modalContent');
      content.innerHTML = html;
      modal.style.display = 'flex';
    }
    // Hide the modal
    function closeModal() {
      const modal = document.getElementById('modal');
      modal.style.display = 'none';
    }
    // Prompt the attacker to choose attack type and handle resolution
    function promptAttack(moveObj, from, to) {
      const attacker = boardState[from.row][from.col];
      const defender = boardState[to.row][to.col];
      // Human player's attack: ask for Base or Super
      if (attacker.color === 'w') {
        const baseD = getBaseDamage(attacker);
        const superD = baseD * 2;
        showModal(
          `<p>You are attacking ${defender.color}${defender.type} with ${attacker.type}. Choose attack:</p>` +
          `<button id="baseAtk">Base (${baseD} dmg)</button>` +
          `<button id="superAtk">Super (${superD} dmg)</button>`
        );
        document.getElementById('baseAtk').onclick = () => { closeModal(); resolveAttack(moveObj, from, to, 'base'); };
        document.getElementById('superAtk').onclick = () => { closeModal(); resolveAttack(moveObj, from, to, 'super'); };
      } else {
        // AI chooses attack automatically
        const option = chooseAIAtack(attacker, defender);
        resolveAttack(moveObj, from, to, option);
      }
    }
    // AI decision for attack type: choose super if it can kill, otherwise random
    function chooseAIAtack(attacker, defender) {
      const baseD = getBaseDamage(attacker);
      if (defender.hp <= baseD) return 'base';
      if (defender.hp <= baseD * 2) return 'super';
      return Math.random() < 0.5 ? 'super' : 'base';
    }
    // Determine if the given colour is the human player
    function isPlayer(color) {
      return color === 'w';
    }
    // Compute base damage, considering accelerated damage toggle
    function getBaseDamage(piece) {
      let dmg = PIECE_STATS[piece.type].dmg;
      if (document.getElementById('accel').checked) {
        dmg += 1;
      }
      return dmg;
    }
    // AI decide whether to use a defend token (tries to prevent lethal hits)
    function shouldAIDefend(attacker, defender, type) {
      const dmg = (type === 'base' ? getBaseDamage(attacker) : getBaseDamage(attacker) * 2);
      return defender.hp - dmg <= 0;
    }
    // Check if the human is allowed to defend (disallowed if in check)
    function allowDefend() {
      return !isCheck('w');
    }
    // Resolve an attack from `from` to `to` of chosen type ('base' or 'super')
    function resolveAttack(moveObj, from, to, type) {
      const attacker = boardState[from.row][from.col];
      const defender = boardState[to.row][to.col];
      const dmg = type === 'base' ? getBaseDamage(attacker) : getBaseDamage(attacker) * 2;
      const isSuper = type === 'super';
      const defColor = defender.color;
      // Flags for whether a defend token is used and whether it succeeded
      let defendUsed = false;
      let defendSuccess = false;
      // If AI is defending (human is attacking)
      if (!isPlayer(defColor)) {
        if (defendTokens[defColor] > 0 && shouldAIDefend(attacker, defender, type)) {
          defendUsed = true;
          defendTokens[defColor]--;
          defendSuccess = Math.random() < 0.5;
          log(`${defColor === 'w' ? 'White' : 'Black'} defended: ${defendSuccess ? 'success' : 'fail'}.`);
        }
        processAttack(defendUsed && defendSuccess);
      } else {
        // Human may choose to defend when AI attacks, if tokens remain and allowed
        if (attacker.color === 'b' && defendTokens.w > 0 && allowDefend()) {
          showModal(
            `<p>Your ${defender.type} is under attack! Use Defend? (${defendTokens.w} left)</p>` +
            `<button id="defYes">Defend</button>` +
            `<button id="defNo">No Defend</button>`
          );
          document.getElementById('defYes').onclick = () => {
            closeModal();
            defendTokens.w--;
            const success = Math.random() < 0.5;
            log(`White used Defend. ${success ? 'Success: blocked.' : 'Failed: no block.'}`);
            processAttack(success);
          };
          document.getElementById('defNo').onclick = () => {
            closeModal();
            processAttack(false);
          };
        } else {
          // No defend offered or available
          processAttack(false);
        }
      }
      // Helper to finish processing the attack after defend decisions
      function processAttack(blocked) {
        // Super: 40% chance to hit
        let hit = true;
        if (isSuper) {
          hit = Math.random() < 0.4;
        }
        if (!hit) {
          log(`${attacker.color === 'w' ? 'White' : 'Black'} used SUPER. Super miss! No damage.`);
          endAfterAttack(false);
          return;
        }
        if (blocked) {
          log(`${attacker.color === 'w' ? 'White' : 'Black'} used ${isSuper ? 'SUPER' : 'BASE'}, but Defend blocked.`);
          endAfterAttack(false);
          return;
        }
        // Apply damage
        defender.hp -= dmg;
        log(`${attacker.color === 'w' ? 'White' : 'Black'} used ${isSuper ? 'SUPER' : 'BASE'}. Hit for ${dmg}. ${defender.type} now at ${defender.hp} HP.`);
        if (defender.hp <= 0) {
          // Capture: move attacker onto defender's square
          log(`${defender.color === 'w' ? 'White' : 'Black'} ${defender.type} defeated.`);
          boardState[to.row][to.col] = attacker;
          boardState[from.row][from.col] = null;
          endAfterAttack(true);
        } else {
          // Bounce: no movement
          endAfterAttack(false);
        }
      }
    }
    // After combat finishes, reset selection and end turn
    function endAfterAttack(moved) {
      selected = null;
      render();
      endTurn();
    }
    // End the current player's turn, check for check/checkmate, then trigger AI move if necessary
    function endTurn() {
      // Swap turn
      turn = turn === 'w' ? 'b' : 'w';
      // Check and announce check or checkmate for the player about to move
      checkAndAnnounce();
      render();
      // If it's now black's turn (AI), perform AI move
      if (turn === 'b') {
        setTimeout(() => aiMove(), 300);
      }
    }
    // Log a message to the log div
    function log(msg) {
      logDiv.innerHTML += msg + '<br>';
      logDiv.scrollTop = logDiv.scrollHeight;
    }
    // Check if a colour is in check
    function isCheck(color) {
      const kingPos = findKing(color);
      if (!kingPos) return false;
      const attacks = getAttacksFrom(color === 'w' ? 'b' : 'w');
      return attacks.some(a => a.row === kingPos.row && a.col === kingPos.col);
    }
    // Determine if a colour is in checkmate
    function isCheckmate(color) {
      return isCheck(color) && getLegalMoves(color).length === 0;
    }
    // Find the king of a given colour on the board
    function findKing(color) {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = boardState[r][c];
          if (piece && piece.type === 'K' && piece.color === color) {
            return { row: r, col: c };
          }
        }
      }
      return null;
    }
    // Generate a list of squares attacked by a colour (for check detection)
    function getAttacksFrom(color) {
      const attacks = [];
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = boardState[r][c];
          if (piece && piece.color === color) {
            const moves = getPseudoMoves(r, c, piece);
            for (const m of moves) {
              attacks.push({ row: m.row, col: m.col });
            }
          }
        }
      }
      return attacks;
    }
    // Generate pseudo-legal moves for a piece (ignoring check and capture lethality)
    function getPseudoMoves(r, c, piece) {
      const moves = [];
      // Pawn moves: only capture diagonally (for attack detection)
      if (piece.type === 'P') {
        const dir = piece.color === 'w' ? -1 : 1;
        [[r + dir, c - 1], [r + dir, c + 1]].forEach(([nr, nc]) => {
          if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
            moves.push({ row: nr, col: nc });
          }
        });
        return moves;
      }
      // Knight moves
      if (piece.type === 'N') {
        const deltas = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
        for (const [dr, dc] of deltas) {
          const nr = r + dr;
          const nc = c + dc;
          if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
            moves.push({ row: nr, col: nc });
          }
        }
        return moves;
      }
      // Direction deltas for sliding pieces and king
      let dirs;
      if (piece.type === 'B') dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
      else if (piece.type === 'R') dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
      else if (piece.type === 'Q') dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1], [1, 0], [-1, 0], [0, 1], [0, -1]];
      else if (piece.type === 'K') dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1], [1, 0], [-1, 0], [0, 1], [0, -1]];
      if (piece.type === 'K') {
        for (const [dr, dc] of dirs) {
          const nr = r + dr;
          const nc = c + dc;
          if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
            moves.push({ row: nr, col: nc });
          }
        }
      } else {
        for (const [dr, dc] of dirs) {
          let nr = r + dr;
          let nc = c + dc;
          while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
            moves.push({ row: nr, col: nc });
            if (boardState[nr][nc]) break;
            nr += dr;
            nc += dc;
          }
        }
      }
      return moves;
    }
    // Generate all legal moves for a colour, considering check and lethal capture rules
    function getLegalMoves(color) {
      const moves = [];
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = boardState[r][c];
          if (!piece || piece.color !== color) continue;
          const pseudo = getPseudoMoves(r, c, piece);
          for (const p of pseudo) {
            const target = boardState[p.row][p.col];
            const isCapture = target && target.color !== color;
            // Skip moving onto friendly pieces
            if (!isCapture && boardState[p.row][p.col]) continue;
            // Skip capturing king (not allowed)
            if (isCapture && target.type === 'K') continue;
            // If in check, capturing must be guaranteed lethal via base attack
            if (isCapture && isCheck(color)) {
              const baseD = PIECE_STATS[piece.type].dmg + (document.getElementById('accel').checked ? 1 : 0);
              if (target.hp > baseD) continue;
            }
            // Simulate move (taking into account bounce for non-lethal capture)
            const savedFrom = boardState[r][c];
            const savedTo = boardState[p.row][p.col];
            // Remove attacker from from-square
            boardState[r][c] = null;
            // If capture and lethal, place attacker on target; otherwise if capture and not lethal, attacker stays put; non-capture moves simply move
            if (isCapture && PIECE_STATS[piece.type].dmg + (document.getElementById('accel').checked ? 1 : 0) >= (target ? target.hp : 0)) {
              boardState[p.row][p.col] = savedFrom;
            } else if (!isCapture) {
              boardState[p.row][p.col] = savedFrom;
            } else {
              // bounce: keep original attacker location
              boardState[r][c] = savedFrom;
              // Revert target (should not change) and skip further simulation; check state is same as before bounce
            }
            const inCheck = isCheck(color);
            // Revert changes
            boardState[r][c] = savedFrom;
            boardState[p.row][p.col] = savedTo;
            if (!inCheck) {
              moves.push({ from: { row: r, col: c }, to: { row: p.row, col: p.col } });
            }
          }
        }
      }
      return moves;
    }
    // Check and log check/checkmate status for the current turn
    function checkAndAnnounce() {
      if (isCheck(turn)) {
        log(`${turn === 'w' ? 'White' : 'Black'} is in check.`);
        if (isCheckmate(turn)) {
          log(`${turn === 'w' ? 'White' : 'Black'} is checkmated!`);
          alert(`${turn === 'w' ? 'White' : 'Black'} is checkmated!`);
        }
      }
    }
    // AI chooses and performs a move on its turn
    function aiMove() {
      const moves = getLegalMoves('b');
      if (moves.length === 0) return;
      // Prefer capturing moves
      const captureMoves = moves.filter(m => {
        const target = boardState[m.to.row][m.to.col];
        return target && target.color === 'w';
      });
      if (captureMoves.length > 0) {
        // Sort to prefer moves that yield largest HP gain (basic heuristic)
        captureMoves.sort((a, b) => {
          const atkA = boardState[a.from.row][a.from.col];
          const defA = boardState[a.to.row][a.to.col];
          const atkB = boardState[b.from.row][b.from.col];
          const defB = boardState[b.to.row][b.to.col];
          const dmgA = getBaseDamage(atkA);
          const dmgB = getBaseDamage(atkB);
          return (defB.hp - dmgB) - (defA.hp - dmgA);
        });
        const mv = captureMoves[0];
        promptAttack(mv, mv.from, mv.to);
      } else {
        // Random non-capture move
        const mv = moves[Math.floor(Math.random() * moves.length)];
        performMove(mv.from, mv.to);
        endTurn();
      }
    }
    // Display the "How to Play" modal
    document.getElementById('howto').addEventListener('click', () => {
      const rules =
        'Piece stats: Pawn 2HP/1 dmg, Knight 4/2, Bishop 4/2, Rook 6/3, Queen 8/4. Kings cannot be damaged or captured.' +
        '\nOn your turn, move as in chess. When capturing: choose Base (auto hits) or Super (double damage, 40% hit). The defender may spend a Defend token (coin flip) to block damage.' +
        '\nDamage resolves before movement; if the target survives, no one moves (the attack bounces).' +
        '\nWhile in check, you cannot use Super or hope to Defend; only base attacks that are guaranteed lethal may be used to escape.' +
        '\nEach side has 3 Defend tokens. Checking the Accelerated Damage box increases all Base damages by 1.' +
        '\nCheckmate the opposing king to win.';
      // Escape HTML and convert newlines to <br>
      const safe = rules
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\n/g, '<br>');
      showModal(`<h3>How to Play</h3><p>${safe}</p><button onclick="document.getElementById('modal').style.display='none'">Close</button>`);
    });
    // Reset button handler
    document.getElementById('reset').addEventListener('click', () => {
      init();
    });
    // Initialise game on page load
    init();
  </script>
</body>
</html>